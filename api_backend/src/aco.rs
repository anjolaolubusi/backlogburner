//Library Imports
//rand::{thread_rng, Rng}, rand_chacham rand_core imports a random number generator
//create::ga is our genetic algorithm implementation
//crate::aco is out ant colony optimization implementation
//rsgenetic::pheno::* imports our Genetic Algorithm genomes

use crate::model;
use crate::ga;
use rand::{thread_rng, Rng};
use rsgenetic::pheno::*;

use rand_chacha::rand_core::SeedableRng;
use rand_core::RngCore;
use rand_chacha; // 0.3.0

//use crate::ga;
//use rand::{seq::SliceRandom, thread_rng, Rng};

/**
 * Abstracted Ant class
 * path - Vector of 128 bit integers tuples that represent the path of the ant
 * curr_node - Tuple of 218 bit integers that represents the current node that the ant is on
 * EndOfCycle - 32 bit float number that represents the last time of block of the schedule
 */
#[derive(Debug, Clone)]
pub struct Ant{
    pub path: Vec<(i128, i128)>, 
    pub curr_node: (i128, i128),
    pub EndOfCycle: f32
}

impl Ant{
    /**
     * Moves Ant to End Node
     * Parameter: 
     *  self: Mutable pointer to the Ant object itselg
     *  to: Tuple of 128 bit integer tuples that represents the next destination of the ant
     * Pre-condition: None
     * Post-condition: Ant is moved to a new node specified by to
     */
    pub fn move_to_end_node(&mut self, to: (i128, i128)){
        self.curr_node = to;
        self.path.push(self.curr_node);
    }
}


/**
 * Abstracted Node class
 * interval - 128 bit integer tuple that represents the interval of the node
 * pheromone - 32 bit floating value that represents the phermone value of the node
 */
#[derive(Debug, Clone, Copy)]
pub struct Node{
    pub interval: (i128, i128),
    pub pheromone: f32
}

/**
 * Abstracted Graph
 * nodes - Vector of node vectors that represents the entire node graph
 */
#[derive(Debug, Clone)]
pub struct Graph{
    pub nodes: Vec<Vec<Node>>
}

impl Graph{
    /**
     * Initalizes Graph
     * Parameters:
     *  self - Mutable pointer to the Graph class
     *  list_of_new_events - Pointer to a vector of RequestedEvent. This vector represents a list of hobbies.
     *  list_of_free_intervals - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are not allocated
     *  model_data - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are allocated
     * Pre-condition: None
     * Post-condition: Ant Colony Graph is initalized
     */
    pub fn init(&mut self, list_of_new_events: &Vec<model::RequestedEvent>, list_of_free_intervals: &Vec<(i128, i128)>, model_data: &Vec<(i128, i128)>){
            let mut nodes = Vec::<Vec<Node>>::new();
            for new_event in list_of_new_events{
                let mut node_list = Vec::<Node>::new();
                for interval in list_of_free_intervals{
                    for i in 1..((interval.1 - interval.0) as f32/(new_event.length/5.0)) as i128 + 1{
                        let mut node: Node = Node{
                            interval: (0, 0),
                            pheromone: 0.0
                        };
                        node.interval = (interval.0 + ((i-1) as f32 * new_event.length/5.0) as i128 , interval.0 + (i as f32 * new_event.length/ 5.0) as i128);
                        node.pheromone = 0.0;
                        if !ga::checkViolations(&node.interval, model_data, &list_of_new_events[0].recurType){
                        node_list.push(node);
                        }
                    }
                }
                nodes.push(node_list);
            }
            self.nodes = nodes;
    }
}

/**
 * Gets a list of paths travelled by the ants
 * Parameters:
 *  ants - Pointer to a vector of Ant objects. This vector represents the total list of ants on the graph
 * Pre-condition: Ants have travelled across the graph
 * Post-contition: A List containing the distinct ant travelled paths is returned
 */
pub fn getDistinctPath(ants: &Vec<Ant>) -> Vec<Vec<(i128, i128)>>{
    let mut temp = Vec::<Vec<(i128, i128)>>::new();
    for ant in ants{
        if(!temp.contains(&ant.path)){
            temp.push(ant.path.to_vec());
        }
    }
    return temp;
}

/**
 * Runs the Ant Colony Optimization Algorithm
 * Parameters:
 *  population - 32 bit integer that represents the total number of ants
 *  list_of_new_events - Pointer to a vector of RequestedEvent. This vector represents a list of hobbies.
 *  list_of_free_intervals - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are not allocated
 *  chromosones - Pointer to a list of MyPheno objects. This vector represents the list of solutions generated by the genetic algorithm portion of GACO
 *  model_data - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are allocated
 *  avgGFit - 32 bit floating variable that represents the average fitness of the solutions generated by the genetic algorithm portion of GACO
 * Pre-condition: The Genetic Algorithm has run and returned it's population pool.
 * Post-condiition: The list of path travalled at the end of the ant colony optimization is returned
 */
pub fn run(population: i32, list_of_new_events: &Vec<model::RequestedEvent>, list_of_free_intervals: &Vec<(i128, i128)>, chromosones: &Vec<ga::MyPheno>, model_data: &Vec<(i128, i128)>, avgGFit: f32) -> Vec<Vec<(i128, i128)>>{
    let mut aco_graph : Graph = Graph{
        nodes: Vec::<Vec<Node>>::new()
    };
    let mut curr_best_path: Vec::<(i128, i128)> = Vec::<(i128, i128)>::new();
    aco_graph.init(list_of_new_events, list_of_free_intervals, model_data);
    let mut possible_path: Vec<Vec<(i128, i128)>> = Vec::<Vec<(i128, i128)>>::new();
    let mut fitness_path: Vec<f32> = Vec::<f32>::new();
    //Check for empty variables
    let mut pheromone_sum: Vec::<f32> = Vec::<f32>::new();
    for chromo in chromosones{
        let path = chromo.getNewEventsList();
        if !possible_path.contains(&path){
            possible_path.push(path.to_vec());
            fitness_path.push(chromo.fitness() as f32);
        }    
    }
    for path in possible_path{
        for i in 0..aco_graph.nodes.len(){
            let index = aco_graph.nodes[i].iter().position(|&r| r.interval == path[i]);
            if index != None{
                aco_graph.nodes[i][index.unwrap()].pheromone = fitness_path[i];
            }
        }
    }

    for i in 0..aco_graph.nodes.len(){
        pheromone_sum.push(0.0);
        for j in 0..aco_graph.nodes[i].len(){
            aco_graph.nodes[i][j].pheromone += avgGFit;
            pheromone_sum[i] += aco_graph.nodes[i][j].pheromone;
        }
    }

    let mut ants: Vec<Ant> = Vec::<Ant>::new();
    for _ in 0..population{
        let ant: Ant = Ant{
            path: Vec::<(i128, i128)>::new(),
            curr_node: (-1, -1),
            EndOfCycle: chromosones[0].EndOfCycle
        };
        ants.push(ant);
    }

    let mut counter = 0;
    let mut listOfDistinctPath: Vec<Vec<(i128, i128)>>  = Vec::<Vec<(i128, i128)>>::new();
    // println!("ACO GRAPH: {:?}", aco_graph);
    while !is_over(&ants, counter){
        for i in 0..aco_graph.nodes.len(){
            //aco_graph.nodes[i].retain(|&x| x.pheromone != 0.0);
            for j in 0..aco_graph.nodes[i].len(){
                if aco_graph.nodes[i][j].pheromone < 1.0{
                    aco_graph.nodes[i][j].pheromone = 0.0;
                }
            }
        }

        // for i in 0..aco_graph.nodes.len(){
        //     aco_graph.nodes[i].retain(|&x| x.pheromone != 0.0);
        // }
        // println!("GRAPH: {:?}", aco_graph);
        //TODO: Get total distinct paths travelled
        reinitalize_ants(&mut ants, population);
        move_ants(&aco_graph, &mut ants, &pheromone_sum, model_data);
        listOfDistinctPath = getDistinctPath(&mut ants);
        update_pheromone(&mut aco_graph, &mut ants, chromosones[0].EndOfCycle, model_data);
        pheromone_sum = get_pheromone_sum(&aco_graph);
        curr_best_path = ants[0].path.clone();
        if cfg!(debug_assertions) {
            // println!("");
        }
        counter += 1;
    }

    // if cfg!(debug_assertions){
    //     println!("Outside Loop: {:?}", ants);
    //     if counter >= 100 {
    //         println!("Hit Limit");
    //     }
    // }
    let mut listOfPaths = Vec::<Vec<(i128, i128)>>::new();
    for ant in ants{
        if !listOfPaths.contains(&ant.path) && !ant.path.is_empty(){
            listOfPaths.push(ant.path);
        }
    }
    listOfPaths.sort_by(|a, b| a.partial_cmp(b).unwrap());
    // println!("LIST OF PATH: {:?}", listOfPaths);
    println!("Num of Iterations: {}", counter);
    return listOfPaths;
    // Add exit conditions
}

/**
 * Gets the sum of all phermone values on the graph
 * Parameters:
 *  aco_graph - Pointer to graph object. This object represents the Ant Colony Optimization graph
 * Pre-condition: None
 * Post-condition: Returns the sum of all pheromone values in each graph node
 */
pub fn get_pheromone_sum(aco_graph: &Graph) -> Vec<f32>{
    let mut pheromone_sum: Vec<f32> = Vec::<f32>::new();
    for i in 0..aco_graph.nodes.len(){
        pheromone_sum.push(0.0);
        for j in 0..aco_graph.nodes[i].len(){
            if aco_graph.nodes[i][j].pheromone < 0.0{
                continue;
            }
            pheromone_sum[i] += aco_graph.nodes[i][j].pheromone;
        }
    }
    return pheromone_sum;
}

/**
 * Gets the sum of all phermone values within a selection
 * Parameters:
 *  node_col - Pointer to a vector of nodes. This parameter represents the a column of nodes in the Ant Colony Optimization graph
 *  path_travelled -  Pointer to a vector of 128 bit integers tuples that represent the path of the ant
 *  model_data - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are allocated
 *  EndOfCycle - 32 bit float number that represents the last time of block of the schedule
 * Pre-condition: None
 * Post-condition: Returns the sum of all the pheromones within a column of nodes
 */
pub fn get_pheromone_col_sum(node_col: &Vec<Node>, path_travelled: &Vec<(i128, i128)>, model_data: &Vec<(i128, i128)>, EndOfCycle: f32) -> f32{
    let mut sum = 0.0;
    for node in node_col{
        sum += node.pheromone;
    }
    return sum;
}

/**
 * Gets the sum of the fitness value of all new paths
 * Parameters:
 *  node_col - Pointer to a vector of nodes. This parameter represents the a column of nodes in the Ant Colony Optimization graph
 *  path_travelled -  Pointer to a vector of 128 bit integers tuples that represent the path of the ant
 *  model_data - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are allocated
 *  EndOfCycle - 32 bit float number that represents the last time of block of the schedule
 * Pre-condition: None
 * Post-condition: Returns the sum of all the fitness values within a column of nodes
 */
pub fn get_fitness_col_sum(node_col: &Vec<Node>, path_travelled: &Vec<(i128, i128)>, model_data: &Vec<(i128, i128)>, EndOfCycle: f32) -> f32{
    let mut sum = 0.0;
    for node in node_col{
        let mut temp_path = path_travelled.clone();
        temp_path.push(node.interval);
        let fitness = calculateFitness(&temp_path, model_data, EndOfCycle);
        sum += fitness;
    }
    return sum;
}

/**
 * Updates pherome value of graph nodes
 * Parameters:
 *  aco_graph - Pointer to graph object. This object represents the Ant Colony Optimization graph
 *  ants - Mutable pointer to vector of Ant objects. This vector represents the total list of ants on the graph
 *  EndOfCycle - 32 bit float number that represents the last time of block of the schedule
 *  model_data - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are allocated
 * Pre-conditions: The ants have travelled across the graph
 * Post-conditions: Phermone values of the graph nodes have changed
 */
pub fn update_pheromone(aco_graph: &mut Graph, ants: &Vec<Ant>, EndOfCycle: f32, model_data: &Vec<(i128, i128)>){
    //Remove Heurisitc Update
    let mut avg_fitness = 0.0;
    for ant_index in 0..ants.len(){
        avg_fitness += calculateFitness(&ants[ant_index].path, &model_data, EndOfCycle);
    }

    for ant_index in 0..ants.len(){
        let fitnesValue = calculateFitness(&ants[ant_index].path, &model_data, EndOfCycle);
        for node_index in 0..ants[ant_index].path.len(){
            let index = aco_graph.nodes[node_index].iter().position(|&r| r.interval == ants[ant_index].path[node_index]);
            if index != None{
                aco_graph.nodes[node_index][index.unwrap()].pheromone += fitnesValue;
            }
        }
    }

    avg_fitness = avg_fitness/ants.len() as f32;
    for i in 0..aco_graph.nodes.len(){
        for j in 0..aco_graph.nodes[i].len(){
            aco_graph.nodes[i][j].pheromone *= 0.5;
        }
    }

}

/**
 * Calculates the fitness of a particular path
 * Parameters:
 *  path - Pointer to a list of 128 bit integer tuples. This variable represents a possible path in the ant colony optimization algorithm
 *  model_data - Pointer to a vector of 128 bit integer tuples. This vector represents a list of time blocks that are allocated
 *  EndOfCycle - 32 bit float number that represents the last time of block of the schedule
 * Pre-condutions: None
 * Post-conditions: Returns the fitness value of a path
 */
pub fn calculateFitness(path: &Vec<(i128, i128)>, model_data: &Vec<(i128, i128)>, EndOfCycle: f32) -> f32{
    let mut minFitness: f32 = 999999999999999.0;
    let mut ListOfFreeTime = Vec::new();
    let mut lastTime: i128 = 0;

    let mut temp_path = model_data.clone();
    for node in path{
        temp_path.push(*node);
    }
    temp_path.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut startIndex = 0;
    if(lastTime == temp_path[0].0){
        lastTime = temp_path[0].1;
        startIndex = 1;
    }
    for x in startIndex..temp_path.len(){
        if(temp_path[x].0 == lastTime){
            lastTime = temp_path[x].1;
            continue;
        }
        ListOfFreeTime.push((lastTime, temp_path[x].0));
        lastTime = temp_path[x].1;
    }
    ListOfFreeTime.push((lastTime, EndOfCycle as i128));

    for x in ListOfFreeTime{
        if (x.1 - x.0).abs() as f32 - minFitness < 0.0{
            minFitness = (x.1 - x.0).abs() as f32;
        }
    }

    return minFitness;

}

/**
 * Moves the ants across the graph
 * Parameters:
 *  aco_graph - Pointer to graph object. This object represents the Ant Colony Optimization graph
 *  ants - Mutable pointer Vector of Ant objects. This vector represents the total list of ants on the graph
 *  pheromone_sum - Pointer to a vector of 32 bit floats. This list represents the pheromone values of each column in the aco graph
 * Pre-condition: Ants are not at the end node
 * Post-condition: Ants are closer to the end node
 */
pub fn move_ants(aco_graph: &Graph, ants: &mut Vec<Ant>, pheromone_sum: &Vec<f32>, model_data: &Vec<(i128, i128)>){
    //Add Heuristic Infomation
    //Change Code to Use Hash Table for Heuristic Infomation Lookup
    let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(0);
    for i in 0..aco_graph.nodes.len(){
        for ant_index in 0..ants.len(){
            let mut prob: f32 = 0.0;
            let mut prob_cap = rng.gen::<f32>();
            for node in &aco_graph.nodes[i]{
                let mut curr_path = ants[ant_index].path.clone();
                curr_path.push(node.interval);
                prob += node.pheromone/ (get_pheromone_col_sum(&aco_graph.nodes[i], &ants[ant_index].path, model_data, ants[ant_index].EndOfCycle));
                if  prob_cap <= prob{
                    ants[ant_index].move_to_end_node(node.interval);
                    break;
                }
            }
        }
    }

}

/**
 * Moves the ants to the start node
 * Parameters:
 *  ants - Mutable pointer Vector of Ant objects. This vector represents the total list of ants on the graph
 *  population - 32 bit integer that represents the total number of ants
 * Pre-condition: None
 * Post-condition: Ants are at the start node
 */
pub fn reinitalize_ants(ants: &mut Vec<Ant>, population: i32){
    let temp = ants[0].EndOfCycle;
    *ants = Vec::<Ant>::new();
    for _ in 0..population{
        let ant: Ant = Ant{
            path: Vec::<(i128, i128)>::new(),
            curr_node: (-1, -1),
            EndOfCycle: temp
        };
        ants.push(ant);
    }
}

/**
 * Checks if the ending conditions has been reached
 * Parameters:
 *  ants - Mutable pointer Vector of Ant objects. This vector represents the total list of ants on the graph
 *  iterationNum - 128 bit integer variable that represents the interation number of the ant colony optimization algorithm
 * Pre-condition: None
 * Post-condition: None
 */
pub fn is_over(ants : &Vec<Ant>, iterationNum: i128) -> bool{
    if iterationNum == 0{
        return false;
    }
    if iterationNum > 100{
        return true;
    }
    for i in 1..ants.len(){
        if(ants[0].path != ants[i].path){
            return false;
        }
    }
    return true;
}